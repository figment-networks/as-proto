import * as assert from "assert";
import * as path from "path";

import {
  CodeGeneratorRequest,
  CodeGeneratorResponse,
} from "google-protobuf/google/protobuf/compiler/plugin_pb";
import { FileDescriptorProto } from "google-protobuf/google/protobuf/descriptor_pb";
import prettier from "prettier";

import { FileContext } from "../file-context";
import { GeneratorContext } from "../generator-context";
import { getPathWithoutProto } from "../names";
import { generateEnum } from "./enum";
import { generateMessage } from "./message";
import { version } from "../../package.json";

export function generateFile(
  fileDescriptor: FileDescriptorProto,
  fileContext: FileContext
): string {
  const filename = fileDescriptor.getName();
  assert.ok(filename);

  const types: string[] = [];
  for (const messageDescriptor of fileDescriptor.getMessageTypeList()) {
    types.push(generateMessage(messageDescriptor, fileContext));
  }
  for (const enumDescriptor of fileDescriptor.getEnumTypeList()) {
    types.push(generateEnum(enumDescriptor, fileContext));
  }

  return `${fileContext.getImportsCode()}\n\n${types.join("\n\n")}`;
}

export function addFile(
  filename: string,
  code: string,
  codeGenResponse: CodeGeneratorResponse,
  protocVersion: string
): void {
  let formattedCode =
    `// Code generated by protoc-gen-as. DO NOT EDIT.\n` +
    `// versions:\n` +
    `// 	 protoc-gen-as v${version}\n` +
    `// 	 protoc        v${protocVersion}\n` +
    `// source: ${filename}\n\n` +
    code;

  try {
    formattedCode = prettier.format(formattedCode, {
      parser: "typescript",
      printWidth: 130,
    });
  } catch (error) {
    console.error(error);
  }

  const outputFile = new CodeGeneratorResponse.File();
  outputFile.setName(filename);
  outputFile.setContent(formattedCode);
  codeGenResponse.addFile(outputFile);
}

export function generateExport(
  codeGenRequest: CodeGeneratorRequest,
  codeGenResponse: CodeGeneratorResponse,
  generatorContext: GeneratorContext,
  protocVersion: string
) {
  const exportFileMap = new Map<string, Set<string>>();
  const indexFileMap = new Map<string, Set<string>>();

  for (const filename of codeGenRequest.getFileToGenerateList()) {
    const packages =
      generatorContext
        .getFileDescriptorByFileName(filename)
        ?.getPackage()
        ?.split(".") || [];
    const filePath = getPathWithoutProto(filename).split("/");

    // Generate the map of file for _export.ts file and the path they
    // should each export
    for (let i = 1; i < filePath.length; i++) {
      const exportFilePath = path.join(...filePath.slice(0, i));
      const toExportPath = filePath[i] as string;
      if (exportFileMap.has(exportFilePath)) {
        exportFileMap.get(exportFilePath)?.add(toExportPath);
      } else {
        exportFileMap.set(exportFilePath, new Set<string>().add(toExportPath));
      }
    }

    // Generate the map of file for index.ts file and the pkg they should
    // each import and re-export
    for (let i = 0; i < filePath.length - 1; i++) {
      const indexFilePath = path.join(...filePath.slice(0, i + 1));
      let pkg = packages[i];
      if (pkg == undefined || pkg == "") {
        // When the file is not defining a package we include it
        // in a package named after the directory
        pkg = filePath[i] as string;
      }

      // We can have more than one element in the set if proto file in the
      // same directory are in different package.
      if (indexFileMap.has(indexFilePath)) {
        indexFileMap.get(indexFilePath)?.add(pkg);
      } else {
        indexFileMap.set(indexFilePath, new Set<string>().add(pkg));
      }
    }
  }

  // Generate the _export.ts files
  for (const filepath of exportFileMap.keys()) {
    const filename = path.join(filepath, "_export.ts");
    let code: string = "";
    const exportPath = exportFileMap.get(filepath) as Set<string>;
    for (const target of exportPath.values()) {
      // Get the package name from the indexFileMap if it exist.
      // Otherwise we export "*".
      const exportName = indexFileMap.get(path.join(filepath, target));
      if (exportName) {
        code += `export { ${[...exportName].join(
          ", "
        )} } from './${target}';\n`;
      } else {
        code += `export * from './${target}';\n`;
      }
    }
    addFile(filename, code, codeGenResponse, protocVersion);
  }

  // Generate the index.ts files
  let rootIndex = "";
  for (const [filepath, pkgs] of indexFileMap) {
    const filename = path.join(filepath, "index.ts");
    let code: string = "";
    for (const target of pkgs) {
      code += `import * as ${target} from './_export';\n`;
    }
    code += `export { ${[...pkgs].join(", ")} };`;
    addFile(filename, code, codeGenResponse, protocVersion);

    // Add export for rootIndex file
    if (filepath.split("/").length == 1) {
      rootIndex += `export { ${[...pkgs].join(", ")} } from './${filepath}';\n`;
    }
  }

  if (rootIndex != "") {
    addFile("./index.ts", rootIndex, codeGenResponse, protocVersion);
  }
}
